定义：
单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。
每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。
总之，选择单例模式就是为了避免不一致状态，避免政出多头。


单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。

特点：
    1、单例类只能有一个实例。
　　2、单例类必须自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。

线程安全：
    在获取单例的时候，要保证不能产生多个实例对象；
    在使用单例对象的时候，要注意单例对象内的实例变量是会被多线程共享的；

实现方式：
    1、饿汉式单例（立即加载方式）
        饿汉式单例在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的，但效率比较低
        Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。
        （事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且闭着眼就认为反射机制不存在。）


    2、懒汉式单例（延迟加载方式）（单例最优方案 线程安全  并且效率高 ）
        需要在getInstance方法上面增加同步锁，以保证线程安全，并且效率高
        此种方式虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行。
        使用双重检查进一步做了优化，可以避免整个方法被锁，只对需要锁的代码部分加锁，可以提高执行效率。

    3、静态内部类实现

    4、static静态代码块实现

    5、内部枚举类实现

注意：
有java本身机制的问题，极端情况下可以破解单例模式
    1.java本身通过反射机制可以调用私有构造器

    2.对象进行反序列化过程，会调用newInstance（）方法，本质也是通过反射机制调用对象的构造器方法，从而破解单例模式